<!DOCTYPE html><html lang="zh_CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux基础 | Ya2gLu</title><meta name="keywords" content="Linux"><meta name="author" content="Ya2gLu"><meta name="copyright" content="Ya2gLu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Linux1.Linux是谁开发的、是用什么语言开发的、Unix的开源精神——这些123451991年Linus Torvalds（林纳斯.托瓦兹）写出Linux内核的第一个版本；  1992年第一个发行版出现；  GNU&#x2F;Linux系统&#x3D;Linux内核+GNU；发行版有：Red Hat,Debain,Suse,Mandrake,Redflag...  GNU：即革奴计划，由理">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础">
<meta property="og:url" content="http://yoursite.com/2020/12/25/Linux/index.html">
<meta property="og:site_name" content="Ya2gLu">
<meta property="og:description" content="Linux1.Linux是谁开发的、是用什么语言开发的、Unix的开源精神——这些123451991年Linus Torvalds（林纳斯.托瓦兹）写出Linux内核的第一个版本；  1992年第一个发行版出现；  GNU&#x2F;Linux系统&#x3D;Linux内核+GNU；发行版有：Red Hat,Debain,Suse,Mandrake,Redflag...  GNU：即革奴计划，由理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2020-12-24T16:00:00.000Z">
<meta property="article:modified_time" content="2022-01-07T00:44:50.315Z">
<meta property="article:author" content="Ya2gLu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/12/25/Linux/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-07 08:44:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">#toggle-sidebar {bottom: 80px}</style><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://rcht8qvm6.hb-bkt.clouddn.com/avater.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Music"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/Movie"><i class="fa-fw /movies/"></i><span> 1</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ya2gLu</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Music"><i class="fa-fw /music/"></i><span> 0</span></a></li><li><a class="site-page child" href="/Movie"><i class="fa-fw /movies/"></i><span> 1</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-12-24T16:00:00.000Z" title="Created 2020-12-25 00:00:00">2020-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-01-07T00:44:50.315Z" title="Updated 2022-01-07 08:44:50">2022-01-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>32min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="1-Linux是谁开发的、是用什么语言开发的、Unix的开源精神——这些"><a href="#1-Linux是谁开发的、是用什么语言开发的、Unix的开源精神——这些" class="headerlink" title="1.Linux是谁开发的、是用什么语言开发的、Unix的开源精神——这些"></a>1.Linux是谁开发的、是用什么语言开发的、Unix的开源精神——这些</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1991年Linus Torvalds（林纳斯.托瓦兹）写出Linux内核的第一个版本；</span><br><span class="line">  1992年第一个发行版出现；</span><br><span class="line">  GNU&#x2F;Linux系统&#x3D;Linux内核+GNU；发行版有：Red Hat,Debain,Suse,Mandrake,Redflag...</span><br><span class="line">  GNU：即革奴计划，由理查德.斯托曼发起，目标是创建一套完全自由的操作系统；</span><br><span class="line">  其他：EMACS、Copyleft</span><br></pre></td></tr></table></figure>

<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>操作系统中负责存取和管理文件的部分；</p>
<h3 id="文件和文件的某些元素的集合，它为链接到文件的文件序列号提供了一个命名空间；"><a href="#文件和文件的某些元素的集合，它为链接到文件的文件序列号提供了一个命名空间；" class="headerlink" title="文件和文件的某些元素的集合，它为链接到文件的文件序列号提供了一个命名空间；"></a>文件和文件的某些元素的集合，它为链接到文件的文件序列号提供了一个命名空间；</h3><h4 id="1）Linux文件系统类型：VFS-EXT2-EXT3-FAT32"><a href="#1）Linux文件系统类型：VFS-EXT2-EXT3-FAT32" class="headerlink" title="1）Linux文件系统类型：VFS / EXT2,EXT3,FAT32"></a>1）Linux文件系统类型：VFS / EXT2,EXT3,FAT32</h4><p>  VFS：virtual file system，虚拟文件系统。一个位于异构文件系统之上的软件粘合层，为访问文件系统的系统调用提供一个统一的抽象接口；它的作用就是采用标准的Unix调用读写位于不同物理介质上的不同文件系统。</p>
<h3 id="2）Linux文件夹结构（常用结构要知道，如boot-root-home-dev这些）"><a href="#2）Linux文件夹结构（常用结构要知道，如boot-root-home-dev这些）" class="headerlink" title="2）Linux文件夹结构（常用结构要知道，如boot,root,home,dev这些）"></a>2）Linux文件夹结构（常用结构要知道，如boot,root,home,dev这些）</h3><p>  在Linux中，所有的文件和目录都被组织成一个根节点开始的倒置的树状结构；<br>  <code>/bin</code>：binary，存放最常使用的命令；<br>  <code>/boot</code>：启动Linux时使用的一些核心文件，包括一些连接文件和镜像文件；<br>  <code>/dev</code>：device，存放Linux的外部设备；在Linux中，访问设备和访问文件的方式是相同的；<br>  <code>/etc</code>：存放所有的系统管理所需要的配置文件和子目录；<br>  <code>/home</code>：用户的主目录<br>  <code>/lib</code>：存放着系统最基本的动态连接共享库；<br>  <code>/media</code>：Linux系统会自动识别一些设备，如U盘、光驱等，识别后，Linux会把被识别的设备挂载到这个目录下；<br>  <code>/mnt</code>：为了让用户临时挂载别的文件系统用，如可以将光驱挂载在/mnt上，然后进入该目录就可以查看光驱里的内容了；<br>  <code>/root</code>：系统管理员的用户主目录；<br>  <code>/tmp</code>：存放一些临时文件<br>  <code>/usr</code>：用户的很多应用程序和文件<br>  <code>/var</code>：存放在不断扩充着的东西，习惯性将那些经常被修改的文件放到这个目录下， 包括各种日志文件；</p>
<h3 id="3）启动过程（理解即可，不用考）"><a href="#3）启动过程（理解即可，不用考）" class="headerlink" title="3）启动过程（理解即可，不用考）"></a>3）启动过程（理解即可，不用考）</h3><p>  BIOS–&gt;MBR–&gt;Boot loader–&gt;Init process</p>
<p>  BIOS检查设备、加载并启动MBR—-MBR中的bootloader（常见有LILO和GRUB两种）加载和启动Linux内核–现在控制权就交给内核了。</p>
<h2 id="安装软件的方式"><a href="#安装软件的方式" class="headerlink" title="安装软件的方式"></a>安装软件的方式</h2><p><code>apt-get command</code></p>
<p>*:apt-get是Debian、Ubuntu发行版的包管理工具，与Redhat中yum工具类似；一般需要root权限：<br>  <code>apt-cache search string</code>：在软件包列表中搜索字符串<br>  <code>apt-get install packagename</code>：安装一个新的软件包<br>  <code>apt-get update</code>;<code> apt-get remove packagename</code>;<code> apt-get remove --purge packagename</code>; <code>apt-get autoremove packagename</code>; <code>apt-get autoclean</code>;…..</p>
<p>   <code>apt</code>属于<strong>Debian</strong>系，<code>rpm</code>属于<strong>Redhat</strong>系；</p>
<h2 id="命令：常用的命令"><a href="#命令：常用的命令" class="headerlink" title="命令：常用的命令"></a>命令：常用的命令</h2><p>  <code>passwd</code>：改变密码；<br>  <code>mkpasswd</code>：生成随机密码；<br>  <code>date</code>：显示当前日期和时间；<br>  <code>cal</code>：显示日历；<br>  <code>who/finger</code>：显示当前系统的active用户（finger需要另外安装，如在Ubuntu中sudo apt install finger）<br> <code> clear</code>：清空屏幕；<br>  <code>echo</code>：直接输出echo后面的文本；<br>  <code>write</code>：向指定登录用户终端发送消息；<br>  <code>wall</code>：向系统当前所有打开的终端发送消息；<br> <code>talk</code>：和指定用户聊天；</p>
<p> <code>msg</code>：用于设置其他用户是否可以直接向当前用户终端发送消息，msg y表示允许，msg n表示禁止；</p>
<h2 id="文件类型——七种"><a href="#文件类型——七种" class="headerlink" title="文件类型——七种"></a>文件类型——七种</h2><p>1）<strong>常规文件</strong>：文本或code数据，没有特殊的内部结构；<br>2）<strong>字符特殊文件</strong>：见3）<br>3）<strong>块特殊文件</strong>：特殊文件代表硬件或逻辑设备，通常在/dev中；字符特殊文件通常是装置文件中的串行端口设备，如键盘、鼠标等一次性读取设备；块特殊文件表示装置文件中的可供存储的接口设备（可随机存取装置）；<br>4）<strong>socket</strong>，即套接口文件/数据接口文件：socket，又名“套接口”，用于描述IP地址和端口，应用程序是通过套接字向网络发送请求或者应答网络请求；例如启动mysql服务器时会产生一个mysql.sock文件；<br>5）<strong>符号链接文件</strong>：symbolic link，类似Windows中的快捷方式<br>6）<strong>目录</strong>：内容的表；目录内文件的列表；</p>
<p>7）<strong>管道文件</strong>：fifo</p>
<h2 id="基本命令——文件系统相关"><a href="#基本命令——文件系统相关" class="headerlink" title="基本命令——文件系统相关"></a>基本命令——文件系统相关</h2><p>1）目录<br>  <code>pwd</code>：显示当前目录<br>  <code>cd</code>：切换目录<br>  <code>mkdir</code>：创建目录；options：-m&lt;权限&gt;，创建目录时同时设置权限；-p：一并建立上层目录（如果不存在）；<br>  <code>rmdir</code>：删除目录（最好是空目录，否则用-r递归删除其下的子目录和文件——但是这样做有危险；即先用rm删除目标目录下的文件，再用rmdir删除这个目录）</p>
<p>  <code>ls</code>：以列表形式显示目录内容，有-l,-a,-R等选项——这个命令很重要，参考8；</p>
<p>2）文件<br>  <code>touch</code>：更新文件权限或最后修改时间（创建文件同样使用这个命令，格式为：touch filename）<br>  <code>cp</code>：复制文件；<code>cp [options] 源文件 目标文件</code>；options：-r/R递归、-l对源文件建立硬链接而非复制文件；-s建立符号链接；<br>  <code>mv</code>：移动和重命名文件/目录； mv source target<br>  <code>ln</code>：链接文件；默认创建硬链接，使用-s选项创建符号链接（软链接）；——参照8<br>  <code>rm</code>：删除文件<br>  <code>cat</code>：输出文件内容</p>
<p>  <code>more/less</code>：逐页显示文件；more以全屏幕的方式按页显示文本文件的内容；less与more类似，不同的是more只能往前（即往下）翻页，而less既允许用户向前，也允许向后浏览文件；</p>
<h2 id="硬链接和符号链接："><a href="#硬链接和符号链接：" class="headerlink" title="硬链接和符号链接："></a>硬链接和符号链接：</h2><p>1）为文件创建硬链接：<code>ln</code>，但不能为目录创建硬链接；创建硬链接后，文件的Inode会被多个文件项公用。文件的硬链接数可以在<code>ls -l</code>后的列表的第二列看到，无额外链接的文件的连接数为1<br>    硬链接可以理解为多个文件指向同一个物理地址，所以不能对目录做硬链接，也不可以在不同的文件系统之间做硬链接；</p>
<p>2）软链接/符号链接：<code>ln -s</code>，将一个路径名链接到一个文件。这些创建出来的软链接文件是一种特别类型的文件，实际上它只是一个文本文件，其中包含了链接时的源文件的路径名，而源文件才是实际包含所有数据的文件；软链接产生的这个文件在<code>ls -l</code>中第一列会显示一个l，即表示符号链接文件（而硬链接的第一列依然是-，即文件）；<br>  软链接可以理解为<strong>快捷方式</strong>（也就是通过它飞快地找到源文件，而不是直接去找物理地址），它本身确实是一个新的文件，它的大小就是符号链接中路径的字节数；所以它具有和源文件不同的inode号，而硬链接并没有建立新文件；此外，软链接可以对目录进行，也可以在不同的文件系统之间做符号链接；<br>注：如果递归地做软链接，<code>ln -s</code>产生的文件会全部指向源文件（即真正的文件）；而cp -s复制产生的符号链接文件只会指向上一个文件（可能是符号链接，也可能就是文件，具体要看源文件的类型）</p>
<p>  软链接时推荐源文件使用绝对路径，如果使用相对路径，则软链接文件（即目标文件）必须与源文件在同一级目录下；</p>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p><code>ls -l</code></p>
<p>文件类型   权限      硬链接数目 所有者 用户组   文件大小     修改时间              文件</p>
<p>​                 -rw——-     3         zfh        zfh     2722        1月 16 19:26        nohup.html</p>
<p>第一列，第一个符号表示文件类型，<code>-</code>表示文件，<code>d</code>表示目录，<code>l</code>表示符号链接文件，<code>b</code>表示块特殊文件，<code>c</code>表示字符特殊文件，其他的还有socket文件<code>s</code>和管道文件<code>p</code>——具体参照7；<br>   后面的九个字符依次表示文件所有者、所有者所在用户组、其他用户对这个文件的权限，rwx分别表示read，write，execute，如果是-则表示没有这项权限；<br>2）第二列，硬链接的数量，如果没有硬链接，默认是1<br>3）第三列，文件所有者<br>4）第四列，文件所有者所在的用户组<br>5）第五列，文件大小，单位是字节，如果是特殊文件（即设备），那么这一列指主设备号（第六列就会是次设备号），如果是目录，那么指目录大小（目录内的inode列表所占空间，而不是里面所有文件的总和大小）<br>6）第六列，文件的创建日期或最近修改日期（centos中依次是月、日、时间，Ubuntu中依次是）</p>
<p>7）第七列，文件名</p>
<h2 id="文件属性修改（chmod-chown-chgrp）"><a href="#文件属性修改（chmod-chown-chgrp）" class="headerlink" title="文件属性修改（chmod, chown, chgrp）"></a>文件属性修改（chmod, chown, chgrp）</h2><p>对于8中的文件属性，如权限、用户、用户组，依次使用<code>chmod</code>, <code>chown</code>,<code>chgrp</code>命令修改；</p>
<p>1）更改文件权限：chmod，两种方式——数字或符号；<br>  对于符号，chmod u/g/o/a  +/-/=  r/w/x 文件或目录；其中u表示user，g表示group，o表示others，a表示all；(注意：用户、操作符、权限必须要连起来写)<br>  对于数字，chmod [-R] xyz 文件或目录，-R表示递归，xyz分别由三组权限属性值对应的数字累加而成，其中r=4,w=2,x=1，如chmod 761 f.txt，就表示f.txt的权限被改成了rwx rw- –x  </p>
<p>2）更改文件所有者或组：chown [-R] user:[group]  filename</p>
<p>3）更改文件所在组：chgrp [-R] group filename；</p>
<p>chown和chgrp需要在root权限下执行；且上面的user和group既可以是名字也可以是ID</p>
<h2 id="umask命令与默认权限"><a href="#umask命令与默认权限" class="headerlink" title="umask命令与默认权限"></a>umask命令与默认权限</h2><p>umask命令用来设置限制新建文件权限的掩码。当新文件创建时，其最初的权限由默认权限与umask掩码共同决定。文件的默认权限是666，即rw-rw-rw-，目录的默认权限是777，即rwxrwxrwx。而在此基础之上，umask设置的掩码将会从以上权限中把相应位置的权限拿走（即删去指定位的权限）<br>  如umask设置的掩码为022，那么新文件的权限上用户组和其他用户的write权限就会被拿走，也就是文件权限变成了644，即rw-r-r-，而新建文件夹的权限也变成了rwxr-xr-x，即755.<br>  再umask设置的掩码为245，即分别拿走属主、用户组、其他用户的写、读、读和执行权限，也就是说新建文件权限变成r—w–w-，即422，而文件夹的权限变成了r-x-wx–w-，即532.<br>  综上，umask掩码的作用即是“拿走”相应位置上的权限（如果有的话——总之，这个位置没有权限了。）<br>  umask语法：<br>    <code>umask</code>，显示当前权限掩码，如0245；umask -S，以符号方式显示当前权限掩码，如u=rx,g=wx,o=w</p>
<p>(数字表示的是删掉的权限，符号表示的是剩下的权限)</p>
<h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p>进程是一个任务，是一个正在执行的程序实例。它由<code>执行程序</code>、它的<code>当前值</code>、<code>状态信息</code>以及通过操作系统管理此进程执行情况的资源组成；<br>  从更小的角度看，进程是由一个<code>地址空间</code>和在这个地址空间内执行的<code>一个或多个线程</code>，以及这些线程所需要的<code>系统资源</code>组成；</p>
<p>  所有的进程都是由其他进程启动的（除了init，它是由Linux内核启动的），这是一个树层次结构，可以用<code>pstree</code>查看</p>
<h2 id="内核和外围程序构成"><a href="#内核和外围程序构成" class="headerlink" title="内核和外围程序构成"></a>内核和外围程序构成</h2><p><code>shell</code>是<strong>用户和操作系统</strong>的接口；</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h2 id="重定向和管道（重点；还有，用shell怎么实现重定向？；管道要理解）"><a href="#重定向和管道（重点；还有，用shell怎么实现重定向？；管道要理解）" class="headerlink" title="重定向和管道（重点；还有，用shell怎么实现重定向？；管道要理解）"></a>重定向和管道（重点；还有，用shell怎么实现重定向？；管道要理解）</h2><p>1）<strong>重定向：Linux重定向是指修改原来默认的一些东西，对原来系统命令的默认执行方式进行改变，比如说将原本会在显示器上显示的输出输出到某一文件中。</strong></p>
<p>  I/O重定向通常与FD（File Descriptor）有关，shell的FD通常为10个，即0-9，常用的有三个，<code>0（stdin，标准输入）</code>、<code>1（stdout，标准输出）</code>、<code>2（stderr，标准错误输出）</code>，默认与<code>keyborad</code>、<code>monitor</code>有关；<br>  用<code>&lt;</code>来改变读进的数据信道（stdin），使之从指定的档案读进；用<code>&gt;</code>来改变送出的数据信道（stdout,stderr），使之输出到指定的档案；<br>  <code>0</code>是<code>&lt;</code>的默认值，因此<code>&lt;</code>与<code>0&lt;</code>是一样的；同理，<code>&gt;</code>与<code>1&gt;</code>是一样的；<br>  在IO重定向中，stdout与stderr的管道会先准备好，才会从stdin读进资料；<br> 基本IO：<br>    cmd <code>&gt; file</code> 把stdout重定向到file文件中；<br>    cmd<code>&gt; &gt; file</code>把stdout重定向到file文件中（追加）；<br>    cmd <code>1&gt; file</code> 把stdout重定向到file文件中；<br>    cmd <code>&gt; file 2&gt;&amp;1 </code>把stdout与stderr一起重定向到file文件中；<br>    cmd <code>2&gt; file</code> 把stderr重定向到file文件中；<br>    cmd <code>2&gt;&gt; file</code> 把stderr重定向到file文件中（追加）；<br>    cmd<code> &gt;&gt; file 2&gt;&amp;1</code> 把stdout与stderr一起重定向到file文件中（追加）；<br>    cmd <code>&lt; file &gt;file2</code>：cmd命令以file文件作为stdin，以file2文件作为stdout；<br>    <code>cat &lt;&gt; file</code> 以读写的方式打开file；<br>    cmd <code>&lt; file</code>：命令以file文件作为stdin；</p>
<p>​    cmd <code>&lt;&lt; delimiter Here document</code>，从stdin中读入，直到遇到delimiter分界符；</p>
<p>2）管道：  管道”|”（pipe line）：上一个命令的stdout接到下一个命令的stdin；<br>一个进程的输出作为另一个进程的输入；<br>例如：ls | wc -l ;  ls | grep ‘txt’; </p>
<h2 id="PATH环境变量：echo-env-set要知道"><a href="#PATH环境变量：echo-env-set要知道" class="headerlink" title="PATH环境变量：echo/env/set要知道"></a>PATH环境变量：echo/env/set要知道</h2><p>1）概念：环境变量是在操作系统中一个具有特定名字的对象，它 包含了一个或者多个应用程序所将使用到的信息。环境变量相对于给系统或用户应用程序设置的一些变量。比如在Windows或DOS操作系统中的path变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找；</p>
<p>2）命令——查看和设置环境变量：<br>  <code>echo</code>：使用echo查看单个环境变量，如：<code>echo $PATH</code>，输出：<br>    /usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin<br>  <code>env</code>：使用env查看所有环境变量<br>  <code>set</code>：使用set查看所有本地定义的环境变量（看起来像是一个个函数）<br>  shell中：在shell中使用【export 变量名=$环境变量名】，可以自定义shell变量，它的值就是环境变量的值。该变量只在当前的shell或其子shell中有效，shell关闭了，变量也就失效了，例如：<br>code:</p>
<p>#!/bin/bash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pa&#x3D;  $PATH</span><br><span class="line">echo &quot;path&#x3D;$pa&quot;</span><br></pre></td></tr></table></figure>

<p>execute,输出:path=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin</p>
<h2 id="三个神器——find、sed、grep（基本概念知道就行，sed后面是正则表达式，大概是干嘛的，grep是干嘛的）、正则表达式不考"><a href="#三个神器——find、sed、grep（基本概念知道就行，sed后面是正则表达式，大概是干嘛的，grep是干嘛的）、正则表达式不考" class="headerlink" title="三个神器——find、sed、grep（基本概念知道就行，sed后面是正则表达式，大概是干嘛的，grep是干嘛的）、正则表达式不考"></a>三个神器——find、sed、grep（基本概念知道就行，sed后面是正则表达式，大概是干嘛的，grep是干嘛的）、正则表达式不考</h2><p>1）<code>find</code>：用来在指定目录下查找文件，参数是查找文件的起始目录，根据文件或正则表达式进行匹配；<br>具体参照：<a target="_blank" rel="noopener" href="https://man.linuxde.net/find">https://man.linuxde.net/find</a><br>2）<code>sed</code>：流编辑器，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区的内容，然后输出到屏幕，接着处理下一行，直到文件末尾；文件的内容并未改变，除非使用重定向存储输出；sed主要用于自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等；<br>具体参照：<a target="_blank" rel="noopener" href="https://man.linuxde.net/sed">https://man.linuxde.net/sed</a><br>3）<code>grep</code>：global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来，是一种强大的文本搜索工具，它能使用正则表达式搜索文件，并把匹配的行打印出来；<br>常见用法：在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：<br>grep match_pattern file_name / grep “match_pattern” file_name </p>
<p>也可以使用管道，cat file_name | grep “match_pattern”，cat的参数也可以是一串字符串，这样后面的grep就是在这个字符串中寻找匹配；</p>
<h2 id="shell编程（一定要掌握，有编程题）"><a href="#shell编程（一定要掌握，有编程题）" class="headerlink" title="shell编程（一定要掌握，有编程题）"></a>shell编程（一定要掌握，有编程题）</h2><h3 id="执行脚本的方法：三种，要看！"><a href="#执行脚本的方法：三种，要看！" class="headerlink" title="执行脚本的方法：三种，要看！"></a>执行脚本的方法：三种，要看！</h3><p>如脚本x.sh<br>1）作为可执行程序：<br>  <code>chmod +x ./x.sh</code>  使脚本具有可执行权限<br>  <code>./x.sh </code> 执行脚本<br>2）作为解释器参数<br>  <code>sh x.sh </code>或 <code>/bin/sh x.sh</code><br>  注：这种方式不需要在脚本第一行指定解释器参数，即#!/bin/bash</p>
<p>3）<code>source x.sh </code>或<code> . x.sh</code></p>
<h3 id="用户变量、环境变量（不单独考，可能有path和home）：参数变量和内部变量要知道"><a href="#用户变量、环境变量（不单独考，可能有path和home）：参数变量和内部变量要知道" class="headerlink" title="用户变量、环境变量（不单独考，可能有path和home）：参数变量和内部变量要知道"></a>用户变量、环境变量（不单独考，可能有path和home）：参数变量和内部变量要知道</h3><p> <strong>用户变量</strong>：shell中自定义的变量<br> <strong>环境变量</strong>：操作系统变量，为OS或应用程序服务，如$PATH；shell也可以自定义；<br> <strong>参数变量</strong>：运行shell时传入的参数，以及额外产生的一些变量<br> <strong>内部变量</strong>：shell中的用户变量只能在当前shell中使用，即内部变量，而不能被shell运行的其他命令或shell程序使用，此时使用export命令可以将局部变量/内部变量编程全局变量（也可以称为环境变量，在shell运行结束后失效）；<br>  三种定义全局变量/环境变量的方式：<br>    1）export name=value<br>    2）name=value;export name</p>
<p>​    3）declare -x name=value</p>
<h2 id="read-shell不会考怎么用、引号的用法要清楚"><a href="#read-shell不会考怎么用、引号的用法要清楚" class="headerlink" title="read shell不会考怎么用、引号的用法要清楚"></a>read shell不会考怎么用、引号的用法要清楚</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1）shell中的引号：</span><br><span class="line">  单引号：单引号中的任何字符都会原样输出，转义失败，变量也是无效的；</span><br><span class="line">  双引号：里面可以有变量，也可以出现转义字符（即$ &#96;&#96; \将分别被bash解释）</span><br><span class="line">2）shell用户变量：</span><br><span class="line">  字符串：$&#123;#name&#125;得到长度；$&#123;name:2:3&#125;从第三个字符开始提取三个字符；&#96;expr index &quot;$&#123;name&#125;&quot;  objectStr&#96;在name中查找objectStr子字符串；x\</span><br><span class="line">  数组：</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">array&#x3D;(v0 v1 v2 &quot;v3&quot;)</span><br><span class="line">array[1000]&#x3D;&quot;m_number&quot;</span><br><span class="line"></span><br><span class="line">#print all elements</span><br><span class="line">echo $&#123;array[@]&#125;</span><br><span class="line">echo $&#123;array[*]&#125;</span><br><span class="line"></span><br><span class="line">#print array length</span><br><span class="line">echo $&#123;#array[@]&#125;</span><br><span class="line">echo $&#123;#array[*]&#125;</span><br><span class="line"></span><br><span class="line">#print a element</span><br><span class="line">echo $&#123;array[1000]&#125;</span><br><span class="line"></span><br><span class="line">#print length of a element</span><br><span class="line">echo $&#123;#array[2]&#125;	输出： [zfh@localhost ss]$ .&#x2F;x.sh</span><br><span class="line">v0 v1 v2 v3 m_number</span><br><span class="line">v0 v1 v2 v3 m_number</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">m_number</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">3）运算符：</span><br><span class="line">  算术运算 &#96;expr $a + $b &#96; (+、-、\* 、&#x2F; 、%)</span><br><span class="line">  条件表达式：用方括号[]包含在内，两端需要留空格；如</span><br><span class="line">    [ $a &#x3D;&#x3D; $b ]</span><br><span class="line">    关系运算：[ $a -gt $b ] （-eq -gt -ne -lg -ge -le）</span><br><span class="line">    布尔运算：[ !false ]、[ true -o false]、 [true -a true]</span><br><span class="line">    逻辑运算：[[ true &amp;&amp; false ]]、 [ true || false ]</span><br><span class="line">    字符串运算：[ $a &#x3D; $b ](!&#x3D; -z  -n)，还有[ $a ]检测字符串a是否为空</span><br><span class="line">    文件测试运算：[ -b $file ]是否为块设备文件（-c, -d, -f, -p, -r , -w, -x, -s, -e）</span><br><span class="line">  注：test命令可以起到和方括号类似的作用，如test $a -eq $b</span><br><span class="line"></span><br><span class="line">4）echo命令</span><br><span class="line"> read命令：读取输入；</span><br><span class="line"> read选项：-p表示后面的输出提示字符，不会换行；-n后面的数字表示输入的字符长度限制；-t限时，-s隐藏输入内容；</span><br></pre></td></tr></table></figure>

<h2 id="要看的：参数、条件、case循环、杂项命令（break、continue、exit…-）、函数（好像不考，建议一看）、算术扩展和参数扩展（好好看一看）"><a href="#要看的：参数、条件、case循环、杂项命令（break、continue、exit…-）、函数（好像不考，建议一看）、算术扩展和参数扩展（好好看一看）" class="headerlink" title="要看的：参数、条件、case循环、杂项命令（break、continue、exit….）、函数（好像不考，建议一看）、算术扩展和参数扩展（好好看一看）"></a>要看的：参数、条件、case循环、杂项命令（break、continue、exit….）、函数（好像不考，建议一看）、算术扩展和参数扩展（好好看一看）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">1）if、for、while、util、case</span><br><span class="line">  注意：</span><br><span class="line">    let &quot;x++&quot;命令，是bash中用于计算的工具，使用变量不需要$</span><br><span class="line">    read命令：如read FILM，读取键盘输入并命名为FILM变量</span><br><span class="line"></span><br><span class="line">2）shell函数：稍微看了一遍</span><br><span class="line">3）shell文件包含：包含外部的脚本用于封装公用的代码</span><br><span class="line"> . filename #注意点号和filename之间有一个空格</span><br><span class="line"> 或者：source filename</span><br><span class="line">4）杂项命令：</span><br><span class="line">  参照：http:&#x2F;&#x2F;blog.163.com&#x2F;bobile45@126&#x2F;blog&#x2F;static&#x2F;96061992201311712658570&#x2F;</span><br><span class="line">  exit n：以退出码n退出脚本运行；即在exit位置退出当前shell，退出码为n，退出后可以使用$?来获得上一个命令的退出码。退出码：0表示成功，非0表示失败，2表示用法不当，127表示命令没有找到，126表示不是可执行的，&gt;&#x3D;128信号产生；</span><br><span class="line">  export：定义环境变量（参照上面三种定义环境变量的方式）；在一个脚本定义了环境变量后，如果在另一个脚本中运行这个脚本，那么两个脚本都可以使用这个被定义的环境变量，直至脚本运行结束；</span><br><span class="line">  set：为shell设置参数变量（目前看只能set value，然后$1的值就会变成value）</span><br><span class="line">  unset：从环境中删除变量或函数（如unset name，那么字符串变量name就被删除了）</span><br><span class="line">  trap：trap &quot;command&quot; exit；退出时执行command命令</span><br><span class="line">  &quot;:&quot;：冒号，空命令</span><br><span class="line">  &quot;.&quot;：点号或source：在当前shell中执行命令——如执行其他脚本，比如在x.sh中写source test.sh，就会在执行到这一行的时候去执行test.sh脚本；</span><br><span class="line"></span><br><span class="line">5）捕获命令输出：即执行命令，然后通过shell去获得命令执行的结果</span><br><span class="line">  $(command) 或 &#96;command&#96;</span><br><span class="line">  如：echo $(ls) 或 echo &#96;ls&#96;</span><br><span class="line"></span><br><span class="line">6）算术扩展——即shell算术运算和条件判断的另一种写法</span><br><span class="line">  $((...))</span><br><span class="line">  如：x&#x3D;$(($x+1))，等价于高级语言里的x++</span><br><span class="line">  又如：(( $x&gt;&#x3D; 2 )),等价于[ $x -ge 2 ]</span><br><span class="line">  注意：双层括号与方括号不一样之处在于中间不需要空格来分割；此外，下面这个示例也可以用&#96;expr ...&#96;的形式；</span><br><span class="line"></span><br><span class="line">7）参数扩展——即针对参数进行一些操作</span><br><span class="line">参数扩展    描述</span><br><span class="line">$&#123;param:-default&#125;  如果param为空，就设置它为default的值</span><br><span class="line">$&#123;#param&#125;  给出param的长度</span><br><span class="line">$&#123;param%word&#125;  从param的尾部开始删除与word匹配的最小部分，然后返回剩余部分</span><br><span class="line">$&#123;param%%word&#125; 从param的尾部开始删除与word匹配的最长部分，然后返回剩余部分</span><br><span class="line">$&#123;param#word&#125;  从param的头部开始删除与word匹配的最小部分，然后返回剩余部分</span><br><span class="line">$&#123;param##word&#125; 从param的头部开始删除与word匹配的最长部分，然后返回剩余部分</span><br><span class="line"></span><br><span class="line">8）即时文档——输入输出重定向的一种，理解为将shell中的变量作为命令的输入;</span><br><span class="line">  command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">  delimiter</span><br><span class="line">  例如： </span><br><span class="line"> #!&#x2F;bin&#x2F;bash</span><br><span class="line">cat &gt;&gt; file.txt &lt;&lt; !fs!</span><br><span class="line">  Hello, this is a here document.</span><br><span class="line">!fs!</span><br><span class="line"> 它将中间的文本作为cat命令的输入，然后将cat命令的输出重定向到了file.txt中；</span><br></pre></td></tr></table></figure>

<p>总结一下，概括来说呢，可以把Linux的命令都看成是shell的内容（因为它们都可以在shell里面使用），然后通过输入输出重定向、函数、流程控制等等使得shell变成了一个编程语言；</p>
<h2 id="程序部分"><a href="#程序部分" class="headerlink" title="程序部分"></a>程序部分</h2><h3 id="gcc的参数（看一下）、扩展名不看"><a href="#gcc的参数（看一下）、扩展名不看" class="headerlink" title="gcc的参数（看一下）、扩展名不看"></a>gcc的参数（看一下）、扩展名不看</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1） gcc -c 编译</span><br><span class="line">  gcc 链接 或 编译+链接</span><br><span class="line">  g++ （C++对应的命令，其实是换了前端）</span><br><span class="line">2）gcc [options] [filename]</span><br><span class="line">  -E：预处理</span><br><span class="line">  -S：预处理+编译</span><br><span class="line">  -c：预处理+编译+汇编（不链接）</span><br><span class="line">  -o output_file：指定输出文件名</span><br><span class="line">  -g：调用调试工具必须的符号信息</span><br><span class="line">  -O&#x2F;On：在程序编译、链接过程中进行优化处理</span><br><span class="line">  -Wall：显示所有的警告信息</span><br><span class="line">  -Idir：指定额外的头文件搜索路径（这里是i的大写）</span><br><span class="line">  -Ldir：指定额外的库文件搜索路径（这里是L的大写）</span><br><span class="line">  -lname：链接时搜索指定的库文件（这里是L的小写）</span><br><span class="line">  -DMACRO[&#x3D;DEFN]：定义MACRO宏</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">  创建静态库（.a）：g++ -c StaticMath.cpp，生成目标文件StaticMath.o，然后ar打包ar -crv libstaticmath.a StaticMath.o，这样就生成了静态库libstaticmath.a</span><br><span class="line">  创建动态库(（.so）：g++ -fPIC -c DynamicMath.cpp生成目标文件，然后g++ -shared -o libdynmath.so，这样就生成了动态库libdynmath.so，注意Linux动态库是libxxx.so形式；</span><br></pre></td></tr></table></figure>

<h2 id="Makefile（原理，给一个Makefile要能看得懂）"><a href="#Makefile（原理，给一个Makefile要能看得懂）" class="headerlink" title="Makefile（原理，给一个Makefile要能看得懂）"></a>Makefile（原理，给一个Makefile要能看得懂）</h2><p>1）makefile描述模块间的依赖关系，定义了整个工程的编译规则，实现了自动化编译（make命令执行Makefile脚本）</p>
<p> make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系；<br> 参照：<a target="_blank" rel="noopener" href="https://blog.csdn.net/haoel/article/details/2886/">https://blog.csdn.net/haoel/article/details/2886/</a></p>
<p>2）makefile语法：<br> target … :  prerequisites…<br>command<br>…..<br>target是目标文件，可以是Object file，也可以是可执行文件；prerequisites是生成target所需要的文件（源文件、目标文件、头文件）；command是make要执行的命令，就是使用上面的prerequisites文件生成target的。<br>实际上就是文件之间的依赖关系，target这一个或多个目标文件依赖于prerequisites中的文件，其中生成规则在command中。说白一点就是：prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行；<br>举例：<br>hello : main.o kbd.o<br>    gcc -o hello main.o kbd.o<br>main.o : main.c defs.h<br>    cc -c main.c<br>kbd.o : kbd.c defs.h command.h<br>    cc -c kbd.c<br>clean :<br>    rm edit main.o kbd.o</p>
<p>注意：command之前是一个Tab键；</p>
<h2 id="GCC编译器为啥要分前端后端？"><a href="#GCC编译器为啥要分前端后端？" class="headerlink" title="GCC编译器为啥要分前端后端？"></a>GCC编译器为啥要分前端后端？</h2><p>将编译器分为前端和后端，前端的功能在于产生一个可以让后端处理的语法树，后端翻译语法树成为GCC的暂存器转换语言（RTL），这样使得前后端独立，使得后端无须考虑多种源语言和目标语言而专注于其他工作，消除了重复开发的工作量，提高了编译系统的开发效率；</p>
<h2 id="文件、文件系统"><a href="#文件、文件系统" class="headerlink" title="文件、文件系统"></a>文件、文件系统</h2><p><code>文件</code>：文件是可以读写、包含类型和权限的对象；<br><code>文件系统</code>：组织文件的方式；文件和某些属性的集合。 它为引用这些文件的文件序列号提供了一个名称空间。<br>文件系统的多种含义： </p>
<ul>
<li>一种特定的文件格式 </li>
<li>按特定格式进行了“格式化”的存储介质 </li>
<li>操作系统（通常在内核中）用来管理文件系统以及对文件进行操作的机制及其实现——这是本章的主要话题；</li>
</ul>
<h2 id="VFS：作用、功能，会在内核产生四种对象：vfs对象的具体含义"><a href="#VFS：作用、功能，会在内核产生四种对象：vfs对象的具体含义" class="headerlink" title="VFS：作用、功能，会在内核产生四种对象：vfs对象的具体含义"></a>VFS：作用、功能，会在内核产生四种对象：vfs对象的具体含义</h2><p>1）VFS的作用和功能： </p>
<ul>
<li><p>为各类文件系统提供了一个统一的操作界面和应用编程接口 </p>
</li>
<li><p>文件的统一管理与抽象都由VFS实现 </p>
</li>
<li><p>VFS将用户的文件操作转换为对应的驱动级别的操作（即统一的系统调用转换为各自驱动级别的操作） </p>
</li>
</ul>
<p>  2）VFS模型：<br>  打开一个文件后，VFS会在内存中创建<code>4个对象 </code></p>
<ul>
<li><p>超级块：用于描述当前的文件系统 </p>
</li>
<li><p>索引节点对象（inode）：用于唯一标识文件 </p>
</li>
<li><p>文件对象：代表一个打开的文件，进程相关 </p>
</li>
<li><p>目录项：用于描述文件的目录关系</p>
</li>
</ul>
<h2 id="硬软链接（重点）"><a href="#硬软链接（重点）" class="headerlink" title="硬软链接（重点）"></a>硬软链接（重点）</h2><p>硬链接：不同的文件名对应同一个inode，不能跨越文件系统，对应系统调用link<br>软链接：存储被链接文件的文件名与路径，可跨越文件系统，对应系统调用symlink</p>
<h2 id="系统调用和库函数的区别，如：open和fopen怎么用，区别是什么"><a href="#系统调用和库函数的区别，如：open和fopen怎么用，区别是什么" class="headerlink" title="系统调用和库函数的区别，如：open和fopen怎么用，区别是什么"></a>系统调用和库函数的区别，如：open和fopen怎么用，区别是什么</h2><p>系统调用和库函数都以C函数的形式出现；<br>1）系统调用： </p>
<ul>
<li>Linux内核的对外接口 </li>
<li>用户程序与内核之间的唯一接口 </li>
<li>提供最小接口<br>2）库函数 </li>
<li>依赖于系统调用 </li>
<li>提供较复杂功能<br>例如标准I/O库<br>3）基本I/O系统调用<br>open/create，close，read，write，lseek<br>dup/dup2<br>fcntl<br>ioctl </li>
</ul>
<h2 id="文件描述符的类型、含义"><a href="#文件描述符的类型、含义" class="headerlink" title="文件描述符的类型、含义"></a>文件描述符的类型、含义</h2><p> 在Linux系统中，打开文件就会获得文件描述符，它是：一个很小的非负整数int fd<br>  Linux内核在打开文件时分配一个文件对象，文件描述符指向内核中的文件描述符表元素，此元素再指向文件对象；<br>  每个进程启动后至少分配3个文件描述符：标准输入、标准输出、标准错误，文件描述符依次为0,1,2，定义与unistd.h。</p>
<p>  基本步骤：open -&gt; read/write -&gt; [lseek] -&gt; close</p>
<h2 id="标准I-O库函数（PPT32-57，之后是高级系统调用，目录有关的函数）"><a href="#标准I-O库函数（PPT32-57，之后是高级系统调用，目录有关的函数）" class="headerlink" title="标准I/O库函数（PPT32-57，之后是高级系统调用，目录有关的函数）"></a>标准I/O库函数（PPT32-57，之后是高级系统调用，目录有关的函数）</h2><p>1）文件流<br>  流与FILE结构：FILE* fp；预定义的指针：stdin,stdout,stderr；<br>  缓冲I/O：三种类型——全缓冲、行缓冲、无缓冲<br>2）标准I/O函数<br>流open/close<br>流read/write</p>
<ul>
<li>每次一个字符的I/O</li>
</ul>
<ul>
<li><p>读取一个字符</p>
</li>
<li><p>输出一个字符</p>
<ul>
<li>每次一行的I/O</li>
</ul>
</li>
<li><p>读一行（从流——即文件）</p>
</li>
<li><p>输出一行至流（文件）</p>
<ul>
<li>直接I/O（二进制I/O）</li>
</ul>
</li>
<li><p>fread和fwrite——不懂诶</p>
<ul>
<li>格式化I/O</li>
</ul>
</li>
<li><p>scanf、fscanf、sscanf</p>
</li>
<li><p>printf、fprintf、sprintf<br>流复位</p>
<ul>
<li>fseek、ftell、rewind</li>
<li>fgetpos、fsetpos<br>流刷新</li>
<li>刷新文件流。把流里的数据立刻写入文件</li>
</ul>
<p>include &lt;stdio.h&gt;</p>
<p>int fflush(FILE *stream)；</p>
</li>
</ul>
<h2 id="文件系统编程的函数"><a href="#文件系统编程的函数" class="headerlink" title="文件系统编程的函数"></a>文件系统编程的函数</h2><p>比如用c写重定向要知道调用什么函数；fcntl大概了解、知道标志位就好；ioctl不考，和驱动相关直接调用驱动代码</p>
<h2 id="缓存I-O的三种模式："><a href="#缓存I-O的三种模式：" class="headerlink" title="缓存I/O的三种模式："></a>缓存I/O的三种模式：</h2><ul>
<li>全缓存：由库函数提供缓存，刷新时才写入</li>
<li>行缓存：完成一行后写入</li>
<li>无缓存</li>
</ul>
<h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>锁起的作用： </p>
<ul>
<li>几个进程同时操作一个文件<br>文件锁的分类： </li>
<li>记录锁 </li>
<li>劝告锁：检查，加锁有应用程序自己控制 </li>
<li>强制锁：检查，加锁由内核控制；影响open() read() write()等系统调用 </li>
<li>共享锁 </li>
<li>排他锁</li>
</ul>
<p>fcntl记录锁——即fcntl来进行锁相关的操作</p>
<ul>
<li><p>用于记录锁的fcntl函数原型<br>#include &lt;unistd.h&gt;<br>#include &lt;fcntl.h&gt;<br>int fcntl(int fd, int cmd, struct flock *lock)<br>flock是一个struct，里面保存了锁的类型、锁开始的位移、锁的字节长度、阻塞锁的进度PID</p>
<p>cmd参数：F_GETLK获得锁信息；F_SETLK设置锁信息；F_SETLKW同设置锁信息，wait方式；</p>
</li>
</ul>
<h3 id="安全性：防护等级大概知道每一级保护到什么程序、缓冲区溢出会考（读代码、找溢出）"><a href="#安全性：防护等级大概知道每一级保护到什么程序、缓冲区溢出会考（读代码、找溢出）" class="headerlink" title="安全性：防护等级大概知道每一级保护到什么程序、缓冲区溢出会考（读代码、找溢出）"></a>安全性：防护等级大概知道每一级保护到什么程序、缓冲区溢出会考（读代码、找溢出）</h3><h3 id="内核主要功能、一般不考编译内核的细节"><a href="#内核主要功能、一般不考编译内核的细节" class="headerlink" title="内核主要功能、一般不考编译内核的细节"></a>内核主要功能、一般不考编译内核的细节</h3><p>操作系统是一系列程序的集合，其中最重要的部分构成了内核<br>单内核/微内核： </p>
<ul>
<li>单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制的文件，模块间通讯通过直接调用函数实现； </li>
<li>微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通讯；<br>Linux内核的能力： </li>
<li>内存管理，文件系统，进程管理，多线程支持，抢占式，多处理器支持</li>
</ul>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p>许多常见驱动的源代码集中在内核源码中<br>也有第三方开发的驱动，可以单独编译成模块.ko<br>编译需要内核头文件的支持<br>此外，所有驱动需要以内核态运行<br>开发驱动的注意事项： </p>
<ul>
<li>不能使用c库来开发驱动程序 </li>
<li>没有内存保护机制（内核态） </li>
<li>小内核栈 </li>
<li>并发上的考虑（大量线程随机运行时驱动的运行情况是否正确）</li>
</ul>
<p>模块之间的通讯： </p>
<ul>
<li>模块是为了完成某种特定任务而设计的，其功能比较的单一，为了丰富系统的功能，所以模块之间常常进行通信。其之间可以共享变量，数据结构，也已调用对方提供的功能函数；<br>模块相关命令： </li>
<li>底层命令 </li>
<li>insmod //加载模块 </li>
<li>rmmod //卸载模块 </li>
<li>高层命令 </li>
<li>modprobe </li>
<li>modprobe -r //释放模块 </li>
<li>moddep //查询模块依赖的所有其他模块 </li>
<li>lsmod //列出已经装载的模块列表 </li>
<li>modinfo //显示模块信息</li>
</ul>
<h2 id="BootLoader-Linux要看、初始化不要、用户态内核态的区别"><a href="#BootLoader-Linux要看、初始化不要、用户态内核态的区别" class="headerlink" title="BootLoader Linux要看、初始化不要、用户态内核态的区别"></a>BootLoader Linux要看、初始化不要、用户态内核态的区别</h2><p>用户态与内核态：<br>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（简称内核态）。此时处理器处于特权级最高的0级（x86的特权级分为4级，0级最高，3级最低）。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。<br>当进程执行用户自己的代码时，处于用户态，特权级为3.</p>
<p>进入内核态： </p>
<ul>
<li>系统调用 </li>
<li>中断处理 </li>
<li>异常</li>
</ul>
<h2 id="系统调用与C库I-O函数"><a href="#系统调用与C库I-O函数" class="headerlink" title="系统调用与C库I/O函数"></a>系统调用与C库I/O函数</h2><p>FD：file descriptor，一个很小的正整数，打开文件时获得<br>在unistd.h中，有STDIN_FILENO（0），STDOUT_FILENO（1），STDERR_FILENO（2）；</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>#include &lt;fcntl.h&gt;<br>int open(const char *pathname, int flags)<br>int open(const char *pathname, int falgs, mode_t mode)<br>int creat(const char *pathname, mode_t mode)<br>(return: a new file descriptor if success; -1 if failure)</p>
<p>参数 “falgs”</p>
<ul>
<li>flags：文件权限</li>
<li>O_RDONLY，O_WRONLY，O_RDWR，即只读、只写、读/写；还有O_CREAT表示如果不存在即创建文件；O_APPEND追加模式，O_TRUNC，O_EXCL</li>
<li>creat函数等价于open使用O_CREAT|O_WRONLY|O_TRUNC</li>
</ul>
<p>参数”mode”</p>
<ul>
<li>用于创建新文件的时指定权限</li>
</ul>
<h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p> 关闭一个文件描述符</p>
<p>include &lt;unistd.h&gt;</p>
<p>int close(int fd);<br>(return 0 if success, -1 if failure)</p>
<h2 id="read-write函数"><a href="#read-write函数" class="headerlink" title="read/write函数"></a>read/write函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include &lt;unistd.h&gt; </span><br><span class="line">ssized_t read(int fd, void *buf, size_t count)——即从fd对应的文件中读count个字节的数据到buf数组里；</span><br><span class="line">(返回读到的字节数，若已到文件尾为0，若出错为1)</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count)——即从buf数组中读count个字节的数据写到fd对应的文件中；</span><br><span class="line">(若成功返回已写的字节数，若出错为-1)</span><br></pre></td></tr></table></figure>

<h2 id="dup-dup2——复制文件描述符"><a href="#dup-dup2——复制文件描述符" class="headerlink" title="dup/dup2——复制文件描述符"></a>dup/dup2——复制文件描述符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">  int dup(int oldfd)</span><br><span class="line">  int dup2(int oldfd, int newfd)</span><br><span class="line">  (return: the new file descriptor if success; -1 if failure)</span><br><span class="line">  作用：例如重定向，参照试卷shell重定向的实现</span><br></pre></td></tr></table></figure>

<h2 id="fcntl——文件控制"><a href="#fcntl——文件控制" class="headerlink" title="fcntl——文件控制"></a>fcntl——文件控制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int fcntl(int fd, int cmd)</span><br><span class="line">int fcntl(int fd, int cmd, long arg)</span><br><span class="line">int fcntl(ing fd, int cmd, struct flock *lock)——操作锁</span><br><span class="line">（返回值：若成功依赖于cmd，若出错返回-1）</span><br><span class="line"></span><br><span class="line">cmd参数：</span><br><span class="line">F_DUPFD：复制文件描述符</span><br><span class="line">F_GETFD&#x2F;F_SETFD</span><br><span class="line">F_GETFL&#x2F;F_SETFL：获得&#x2F;设置FD flags，即权限</span><br><span class="line">F_GETOWN&#x2F;F_SETOWN</span><br><span class="line">F_GETLK&#x2F;F_SETLK&#x2F;F_SETLKW：获得&#x2F;设置文件锁，W表示等待</span><br></pre></td></tr></table></figure>

<h2 id="标准I-O库函数——全部位于-include"><a href="#标准I-O库函数——全部位于-include" class="headerlink" title="标准I/O库函数——全部位于#include"></a>标准I/O库函数——全部位于#include</h2><h3 id="文件流（FILE-）"><a href="#文件流（FILE-）" class="headerlink" title="文件流（FILE *）"></a>文件流（FILE *）</h3><p>FILE* fp;<br>缓冲IO：全缓冲、行缓冲、无缓冲</p>
<h3 id="标准I-O库函数"><a href="#标准I-O库函数" class="headerlink" title="标准I/O库函数"></a>标准I/O库函数</h3><p>都是针对流，即FILE*结构进行的操作；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1）open&#x2F;close</span><br><span class="line"> FILE *fopen(const char *filename, const char *mode)</span><br><span class="line"> int fclose(FILE *stream)</span><br><span class="line">mode参数：r, w, a, r+, w+, a+分别表示读、写、追加、读和写、读写创建、读追加创建</span><br><span class="line"></span><br><span class="line">2）read&#x2F;write</span><br><span class="line">每次一个字符的I&#x2F;O</span><br><span class="line">  int getc(File * fp)</span><br><span class="line">  int fgetc(File *fp)</span><br><span class="line">  int getchar(void)</span><br><span class="line">  返回值时字符转换的int，EOF（end of file，用feof(char)来判断），error（ferror(char)判断）</span><br><span class="line"></span><br><span class="line">  int putc(int c, File *fp)</span><br><span class="line">  int fputc(int c,File *fp)</span><br><span class="line">  int putchar(int c)</span><br><span class="line">  返回char如果成功，失败返回-1</span><br><span class="line"></span><br><span class="line">每次一行的I&#x2F;O——从流中读size放到数组中，或把数组写到流中</span><br><span class="line">  char *fgets(char *s, int size, FILE *stream)</span><br><span class="line">  读最多size-1个字符，第size为换行（\0），或EOF</span><br><span class="line"></span><br><span class="line">  int fputs(const char *s, FILE *stream)</span><br><span class="line"></span><br><span class="line">直接I&#x2F;O（二进制I&#x2F;O）</span><br><span class="line">  fread和fwrite</span><br><span class="line"></span><br><span class="line">格式化I&#x2F;O</span><br><span class="line">  scanf, fscanf,sscanf</span><br><span class="line">  printf, fprintf, sprintf</span><br><span class="line">  </span><br><span class="line">  3）流复位</span><br><span class="line">  </span><br><span class="line">  4）流刷新</span><br><span class="line">  刷新文件流。把流里的数据立即写入文件</span><br><span class="line">  int fflush(FILE *stream)</span><br><span class="line"></span><br><span class="line">5）流与文件描述符的相互转换</span><br><span class="line">int fileno(FILE *fp) ——确定流使用的底层文件描述符</span><br><span class="line">FILE *fdopen(int fd)——根据已打开的文件描述符创建一个流</span><br></pre></td></tr></table></figure>

<h2 id="高级系统调用——位于-include"><a href="#高级系统调用——位于-include" class="headerlink" title="高级系统调用——位于#include"></a>高级系统调用——位于#include</h2><h3 id="权限函数"><a href="#权限函数" class="headerlink" title="权限函数"></a>权限函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int access(const char *pathname, int mode)返回0成功，-1失败</span><br><span class="line">mode:R_OK，W_OK，X_OK，F_OK</span><br></pre></td></tr></table></figure>

<h3 id="chmod-fchmod函数——改变文件权限"><a href="#chmod-fchmod函数——改变文件权限" class="headerlink" title="chmod/fchmod函数——改变文件权限"></a>chmod/fchmod函数——改变文件权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int chmod(const char *path, mode_t mode)</span><br><span class="line">int fchmod(int fildes, mode_t mode)</span><br><span class="line">(return 0 if success, -1 if failure)</span><br></pre></td></tr></table></figure>

<h3 id="chown-fchown-lchown函数——改变文件属主和用户组"><a href="#chown-fchown-lchown函数——改变文件属主和用户组" class="headerlink" title="chown/fchown/lchown函数——改变文件属主和用户组"></a>chown/fchown/lchown函数——改变文件属主和用户组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#inculde &lt;unistd.h&gt;</span><br><span class="line">int chown(const char *path, uid_t owner, gid_t group)</span><br><span class="line">int fchown(int fd, uid_owner, gid_t group)</span><br><span class="line">int lchown(const char *path, uid_t owner, gid_t group)</span><br><span class="line">&#96;&#96;</span><br><span class="line">4.link&#x2F;unlink函数</span><br><span class="line">创建文件的链接：</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int link(const char *oldpath, const char *newpath)——对应了硬链接</span><br><span class="line">删除一个名词，以及它可能引用的名称：</span><br><span class="line">int unlink(const char *pathname)</span><br></pre></td></tr></table></figure>

<h3 id="symlink-readlink函数"><a href="#symlink-readlink函数" class="headerlink" title="symlink/readlink函数"></a>symlink/readlink函数</h3><p>创建新链接（包含了oldpath的新文件）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int symlink(const char *oldpath, const char *newpath)</span><br><span class="line">读符号链接的值：</span><br><span class="line">int readlink(const char *path, ch)</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://yoursite.com">Ya2gLu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/12/25/Linux/">http://yoursite.com/2020/12/25/Linux/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/25/JS%20window%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/ya2glu/picgo_bed/raw/master/img/idh1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">JS window对象详解</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/30/2020-9-30/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/ya2glu/picgo_bed/raw/master/img/windows%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%A4%87%E5%BF%98.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">windows系统常用软件集合</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://rcht8qvm6.hb-bkt.clouddn.com/avater.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ya2gLu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ya2gLu"><i class="fab fa-github"></i><span>欢迎订阅</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ya2gLu" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">博客初级阶段</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-number">1.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux%E6%98%AF%E8%B0%81%E5%BC%80%E5%8F%91%E7%9A%84%E3%80%81%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%9A%84%E3%80%81Unix%E7%9A%84%E5%BC%80%E6%BA%90%E7%B2%BE%E7%A5%9E%E2%80%94%E2%80%94%E8%BF%99%E4%BA%9B"><span class="toc-number">1.1.</span> <span class="toc-text">1.Linux是谁开发的、是用什么语言开发的、Unix的开源精神——这些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%8C%E5%AE%83%E4%B8%BA%E9%93%BE%E6%8E%A5%E5%88%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%87%E4%BB%B6%E5%BA%8F%E5%88%97%E5%8F%B7%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9B"><span class="toc-number">1.2.1.</span> <span class="toc-text">文件和文件的某些元素的集合，它为链接到文件的文件序列号提供了一个命名空间；</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%EF%BC%9AVFS-EXT2-EXT3-FAT32"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1）Linux文件系统类型：VFS &#x2F; EXT2,EXT3,FAT32</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89Linux%E6%96%87%E4%BB%B6%E5%A4%B9%E7%BB%93%E6%9E%84%EF%BC%88%E5%B8%B8%E7%94%A8%E7%BB%93%E6%9E%84%E8%A6%81%E7%9F%A5%E9%81%93%EF%BC%8C%E5%A6%82boot-root-home-dev%E8%BF%99%E4%BA%9B%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2）Linux文件夹结构（常用结构要知道，如boot,root,home,dev这些）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%90%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%8C%E4%B8%8D%E7%94%A8%E8%80%83%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">3）启动过程（理解即可，不用考）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">安装软件的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">命令：常用的命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94%E4%B8%83%E7%A7%8D"><span class="toc-number">1.5.</span> <span class="toc-text">文件类型——七种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3"><span class="toc-number">1.6.</span> <span class="toc-text">基本命令——文件系统相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">硬链接和符号链接：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.</span> <span class="toc-text">文件属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%EF%BC%88chmod-chown-chgrp%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">文件属性修改（chmod, chown, chgrp）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#umask%E5%91%BD%E4%BB%A4%E4%B8%8E%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90"><span class="toc-number">1.10.</span> <span class="toc-text">umask命令与默认权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.11.</span> <span class="toc-text">进程概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%92%8C%E5%A4%96%E5%9B%B4%E7%A8%8B%E5%BA%8F%E6%9E%84%E6%88%90"><span class="toc-number">1.12.</span> <span class="toc-text">内核和外围程序构成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">1.13.</span> <span class="toc-text">命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%9B%E8%BF%98%E6%9C%89%EF%BC%8C%E7%94%A8shell%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9F%EF%BC%9B%E7%AE%A1%E9%81%93%E8%A6%81%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.14.</span> <span class="toc-text">重定向和管道（重点；还有，用shell怎么实现重定向？；管道要理解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PATH%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%9Aecho-env-set%E8%A6%81%E7%9F%A5%E9%81%93"><span class="toc-number">1.15.</span> <span class="toc-text">PATH环境变量：echo&#x2F;env&#x2F;set要知道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94find%E3%80%81sed%E3%80%81grep%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%9F%A5%E9%81%93%E5%B0%B1%E8%A1%8C%EF%BC%8Csed%E5%90%8E%E9%9D%A2%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E5%A4%A7%E6%A6%82%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%8Cgrep%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%89%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E8%80%83"><span class="toc-number">1.16.</span> <span class="toc-text">三个神器——find、sed、grep（基本概念知道就行，sed后面是正则表达式，大概是干嘛的，grep是干嘛的）、正则表达式不考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%E5%AE%9A%E8%A6%81%E6%8E%8C%E6%8F%A1%EF%BC%8C%E6%9C%89%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%89"><span class="toc-number">1.17.</span> <span class="toc-text">shell编程（一定要掌握，有编程题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%E4%B8%89%E7%A7%8D%EF%BC%8C%E8%A6%81%E7%9C%8B%EF%BC%81"><span class="toc-number">1.17.1.</span> <span class="toc-text">执行脚本的方法：三种，要看！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88%E4%B8%8D%E5%8D%95%E7%8B%AC%E8%80%83%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%9C%89path%E5%92%8Chome%EF%BC%89%EF%BC%9A%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E8%A6%81%E7%9F%A5%E9%81%93"><span class="toc-number">1.17.2.</span> <span class="toc-text">用户变量、环境变量（不单独考，可能有path和home）：参数变量和内部变量要知道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read-shell%E4%B8%8D%E4%BC%9A%E8%80%83%E6%80%8E%E4%B9%88%E7%94%A8%E3%80%81%E5%BC%95%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95%E8%A6%81%E6%B8%85%E6%A5%9A"><span class="toc-number">1.18.</span> <span class="toc-text">read shell不会考怎么用、引号的用法要清楚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E7%9C%8B%E7%9A%84%EF%BC%9A%E5%8F%82%E6%95%B0%E3%80%81%E6%9D%A1%E4%BB%B6%E3%80%81case%E5%BE%AA%E7%8E%AF%E3%80%81%E6%9D%82%E9%A1%B9%E5%91%BD%E4%BB%A4%EF%BC%88break%E3%80%81continue%E3%80%81exit%E2%80%A6-%EF%BC%89%E3%80%81%E5%87%BD%E6%95%B0%EF%BC%88%E5%A5%BD%E5%83%8F%E4%B8%8D%E8%80%83%EF%BC%8C%E5%BB%BA%E8%AE%AE%E4%B8%80%E7%9C%8B%EF%BC%89%E3%80%81%E7%AE%97%E6%9C%AF%E6%89%A9%E5%B1%95%E5%92%8C%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%EF%BC%88%E5%A5%BD%E5%A5%BD%E7%9C%8B%E4%B8%80%E7%9C%8B%EF%BC%89"><span class="toc-number">1.19.</span> <span class="toc-text">要看的：参数、条件、case循环、杂项命令（break、continue、exit….）、函数（好像不考，建议一看）、算术扩展和参数扩展（好好看一看）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%83%A8%E5%88%86"><span class="toc-number">1.20.</span> <span class="toc-text">程序部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E7%9C%8B%E4%B8%80%E4%B8%8B%EF%BC%89%E3%80%81%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%8D%E7%9C%8B"><span class="toc-number">1.20.1.</span> <span class="toc-text">gcc的参数（看一下）、扩展名不看</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Makefile%EF%BC%88%E5%8E%9F%E7%90%86%EF%BC%8C%E7%BB%99%E4%B8%80%E4%B8%AAMakefile%E8%A6%81%E8%83%BD%E7%9C%8B%E5%BE%97%E6%87%82%EF%BC%89"><span class="toc-number">1.21.</span> <span class="toc-text">Makefile（原理，给一个Makefile要能看得懂）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%BA%E5%95%A5%E8%A6%81%E5%88%86%E5%89%8D%E7%AB%AF%E5%90%8E%E7%AB%AF%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">GCC编译器为啥要分前端后端？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.23.</span> <span class="toc-text">文件、文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VFS%EF%BC%9A%E4%BD%9C%E7%94%A8%E3%80%81%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%BC%9A%E5%9C%A8%E5%86%85%E6%A0%B8%E4%BA%A7%E7%94%9F%E5%9B%9B%E7%A7%8D%E5%AF%B9%E8%B1%A1%EF%BC%9Avfs%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89"><span class="toc-number">1.24.</span> <span class="toc-text">VFS：作用、功能，会在内核产生四种对象：vfs对象的具体含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.25.</span> <span class="toc-text">硬软链接（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A6%82%EF%BC%9Aopen%E5%92%8Cfopen%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.26.</span> <span class="toc-text">系统调用和库函数的区别，如：open和fopen怎么用，区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%81%E5%90%AB%E4%B9%89"><span class="toc-number">1.27.</span> <span class="toc-text">文件描述符的类型、含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-O%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%88PPT32-57%EF%BC%8C%E4%B9%8B%E5%90%8E%E6%98%AF%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%8C%E7%9B%AE%E5%BD%95%E6%9C%89%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.28.</span> <span class="toc-text">标准I&#x2F;O库函数（PPT32-57，之后是高级系统调用，目录有关的函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.29.</span> <span class="toc-text">文件系统编程的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98I-O%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.30.</span> <span class="toc-text">缓存I&#x2F;O的三种模式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81"><span class="toc-number">1.31.</span> <span class="toc-text">文件锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A%E9%98%B2%E6%8A%A4%E7%AD%89%E7%BA%A7%E5%A4%A7%E6%A6%82%E7%9F%A5%E9%81%93%E6%AF%8F%E4%B8%80%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%88%B0%E4%BB%80%E4%B9%88%E7%A8%8B%E5%BA%8F%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%BC%9A%E8%80%83%EF%BC%88%E8%AF%BB%E4%BB%A3%E7%A0%81%E3%80%81%E6%89%BE%E6%BA%A2%E5%87%BA%EF%BC%89"><span class="toc-number">1.31.1.</span> <span class="toc-text">安全性：防护等级大概知道每一级保护到什么程序、缓冲区溢出会考（读代码、找溢出）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E3%80%81%E4%B8%80%E8%88%AC%E4%B8%8D%E8%80%83%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">1.31.2.</span> <span class="toc-text">内核主要功能、一般不考编译内核的细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.32.</span> <span class="toc-text">驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BootLoader-Linux%E8%A6%81%E7%9C%8B%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E8%A6%81%E3%80%81%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.33.</span> <span class="toc-text">BootLoader Linux要看、初始化不要、用户态内核态的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8EC%E5%BA%93I-O%E5%87%BD%E6%95%B0"><span class="toc-number">1.34.</span> <span class="toc-text">系统调用与C库I&#x2F;O函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.35.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close%E5%87%BD%E6%95%B0"><span class="toc-number">1.36.</span> <span class="toc-text">close函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read-write%E5%87%BD%E6%95%B0"><span class="toc-number">1.37.</span> <span class="toc-text">read&#x2F;write函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dup-dup2%E2%80%94%E2%80%94%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.38.</span> <span class="toc-text">dup&#x2F;dup2——复制文件描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fcntl%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">1.39.</span> <span class="toc-text">fcntl——文件控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-O%E5%BA%93%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%85%A8%E9%83%A8%E4%BD%8D%E4%BA%8E-include"><span class="toc-number">1.40.</span> <span class="toc-text">标准I&#x2F;O库函数——全部位于#include</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%88FILE-%EF%BC%89"><span class="toc-number">1.40.1.</span> <span class="toc-text">文件流（FILE *）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-O%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.40.2.</span> <span class="toc-text">标准I&#x2F;O库函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E2%80%94%E2%80%94%E4%BD%8D%E4%BA%8E-include"><span class="toc-number">1.41.</span> <span class="toc-text">高级系统调用——位于#include</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.41.1.</span> <span class="toc-text">权限函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chmod-fchmod%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">1.41.2.</span> <span class="toc-text">chmod&#x2F;fchmod函数——改变文件权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chown-fchown-lchown%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E5%B1%9E%E4%B8%BB%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">1.41.3.</span> <span class="toc-text">chown&#x2F;fchown&#x2F;lchown函数——改变文件属主和用户组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#symlink-readlink%E5%87%BD%E6%95%B0"><span class="toc-number">1.41.4.</span> <span class="toc-text">symlink&#x2F;readlink函数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/25/JS%20window%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/" title="JS window对象详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/ya2glu/picgo_bed/raw/master/img/idh1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS window对象详解"/></a><div class="content"><a class="title" href="/2020/12/25/JS%20window%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/" title="JS window对象详解">JS window对象详解</a><time datetime="2020-12-24T16:00:00.000Z" title="Created 2020-12-25 00:00:00">2020-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/25/Linux/" title="Linux基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux基础"/></a><div class="content"><a class="title" href="/2020/12/25/Linux/" title="Linux基础">Linux基础</a><time datetime="2020-12-24T16:00:00.000Z" title="Created 2020-12-25 00:00:00">2020-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/30/2020-9-30/" title="windows系统常用软件集合"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/ya2glu/picgo_bed/raw/master/img/windows%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%A4%87%E5%BF%98.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="windows系统常用软件集合"/></a><div class="content"><a class="title" href="/2020/09/30/2020-9-30/" title="windows系统常用软件集合">windows系统常用软件集合</a><time datetime="2020-09-29T16:00:00.000Z" title="Created 2020-09-30 00:00:00">2020-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/05/(%E5%89%8D%E7%AB%AF)%E7%94%B5%E5%AD%90%E7%AD%BE%E5%8A%9F%E8%83%BD/" title="电子业务中的电子签功能"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/ya2glu/picgo_bed/raw/master/img/dzqm.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="电子业务中的电子签功能"/></a><div class="content"><a class="title" href="/2020/09/05/(%E5%89%8D%E7%AB%AF)%E7%94%B5%E5%AD%90%E7%AD%BE%E5%8A%9F%E8%83%BD/" title="电子业务中的电子签功能">电子业务中的电子签功能</a><time datetime="2020-09-04T16:00:00.000Z" title="Created 2020-09-05 00:00:00">2020-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/08/31/Canvas/" title="Canvas 学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/ya2glu/picgo_bed/raw/master/img/idxcanvas1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Canvas 学习"/></a><div class="content"><a class="title" href="/2020/08/31/Canvas/" title="Canvas 学习">Canvas 学习</a><time datetime="2020-08-30T16:00:00.000Z" title="Created 2020-08-31 00:00:00">2020-08-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Ya2gLu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><div class="aplayer no-destroy" data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>